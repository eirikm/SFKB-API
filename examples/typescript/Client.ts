/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.1.0 (NJsonSchema v10.0.19.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

namespace SFKB_API {

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://virtserver.swaggerhub.com/meastp/sfkb-update-api-draft/1.0.0";
    }

    /**
     * Hent liste over tilgjengelige dataset
     * @return OK
     */
    getDatasets(): Promise<Dataset[]> {
        let url_ = this.baseUrl + "/datasets";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDatasets(_response);
        });
    }

    protected processGetDatasets(response: Response): Promise<Dataset[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Dataset.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Dataset[]>(<any>null);
    }

    /**
     * Hent metadata for et bestemt dataset
     * @param datasetId UUID of the dataset to get
     * @return OK
     */
    getDatasetMetadata(datasetId: string): Promise<Dataset> {
        let url_ = this.baseUrl + "/datasets/{datasetId}";
        if (datasetId === undefined || datasetId === null)
            throw new Error("The parameter 'datasetId' must be defined.");
        url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDatasetMetadata(_response);
        });
    }

    protected processGetDatasetMetadata(response: Response): Promise<Dataset> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Dataset.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Dataset>(<any>null);
    }

    /**
     * Hent ut features fra et dataset
     * @param datasetId UUID of the dataset to get
     * @param lock (optional) TODO: Beskrive låsing
     * @param bbox (optional) Henter ut objekter i et bestemt område (angitt med et rektangel)
    
    Dette kan være aktuelt for å få ut alle objekter som ikke er direkte knyttet til et objekt, som f.eks mønelinje og takkant til en bygning.
    
    Eksempel: Hent ut et 10x10m rektangel
    
    **TODO: Usikker på syntaks**
    
    ?bbox=(10,10,20,20)
     * @param query (optional) Filter på egenskaper og/eller objekttype for å begrense hvilke features som hentes ut.
    
    Dersom objekttypen ikke skal begrenses, kan den angis med `*`
    
    Eksempel: Hent en bygning med bestemt bygningsnummer
    
    `?query=eq(Bygning/bygningsnummer,1234)`
    
    Eksempel: Hent et objekt med bestemt lokalid
    
    Merk: Når et objekt hentes ut med lokalid er det normalt ikke nødvendig å filtrere på objekttype, derfor er objekttypen angitt med `*`.
    
    Merk: Spørringer er foreløpig begrenset til eksemplene over, nemlig spørringer etter bygningsnummer og lokalid.
    
    Generell regel for egenskapsspørringer:
    
    For å angi hvilken objekttype og hvilket attributt (full struktur med struct-/liste-egenskaper) det spørres etter, bruker vi
    
    > \<objekttypenavn\>/\<attributtnavn\> [ / \<attributtnavn\> …]
    
    Hvis vi ikke ønsker å begrense spørringen til en bestemt objekttype, kan vi angi * som <objekttypenavn>.
     * @return OK
     */
    getData(datasetId: string, lock: Lock | undefined, bbox: BoundingBox | undefined, query: string | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/datasets/{datasetId}/features?";
        if (datasetId === undefined || datasetId === null)
            throw new Error("The parameter 'datasetId' must be defined.");
        url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId)); 
        if (lock === null)
            throw new Error("The parameter 'lock' cannot be null.");
        else if (lock !== undefined)
            url_ += "lock=" + encodeURIComponent("" + lock) + "&"; 
        if (bbox === null)
            throw new Error("The parameter 'bbox' cannot be null.");
        else if (bbox !== undefined)
            url_ += "bbox=" + encodeURIComponent("" + bbox) + "&"; 
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/vnd.kartverket.sosi+gml"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetData(_response);
        });
    }

    protected processGetData(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Endre features i et dataset
     * @param datasetId UUID of the dataset to get
     * @param lock (optional) TODO: Beskrive låsing
     * @param body Optional description in *Markdown*
     * @return OK
     */
    updateData(datasetId: string, lock: Lock2 | undefined, body: Blob): Promise<void> {
        let url_ = this.baseUrl + "/datasets/{datasetId}/features?";
        if (datasetId === undefined || datasetId === null)
            throw new Error("The parameter 'datasetId' must be defined.");
        url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId)); 
        if (lock === null)
            throw new Error("The parameter 'lock' cannot be null.");
        else if (lock !== undefined)
            url_ += "lock=" + encodeURIComponent("" + lock) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/vnd.kartverket.sosi+wfs-t",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateData(_response);
        });
    }

    protected processUpdateData(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Hent liste over alle låser som brukeren har
     * @return OK
     */
    getAllLocks(): Promise<Anonymous[]> {
        let url_ = this.baseUrl + "/locks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllLocks(_response);
        });
    }

    protected processGetAllLocks(response: Response): Promise<Anonymous[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Anonymous.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous[]>(<any>null);
    }

    /**
     * Hent informasjon om brukerens låste features i et bestemt dataset.
     * @param datasetId UUID of the dataset to get
     * @return OK
     */
    getLocksForDataset(datasetId: string): Promise<Locks> {
        let url_ = this.baseUrl + "/locks/{datasetId}";
        if (datasetId === undefined || datasetId === null)
            throw new Error("The parameter 'datasetId' must be defined.");
        url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLocksForDataset(_response);
        });
    }

    protected processGetLocksForDataset(response: Response): Promise<Locks> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Locks.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Locks>(<any>null);
    }

    /**
     * Fjerne alle låser brukeren har i et bestemt dataset
     * @param datasetId UUID of the dataset to delete locks in
     * @return No Content
     */
    deleteLocksForDataset(datasetId: string): Promise<void> {
        let url_ = this.baseUrl + "/locks/{datasetId}";
        if (datasetId === undefined || datasetId === null)
            throw new Error("The parameter 'datasetId' must be defined.");
        url_ = url_.replace("{datasetId}", encodeURIComponent("" + datasetId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteLocksForDataset(_response);
        });
    }

    protected processDeleteLocksForDataset(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("A server error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class Dataset implements IDataset {
    id!: string;
    name!: string;
    kommune?: number;
    fylke?: number;
    sone?: number;
    description?: string;
    resolution?: number;
    coordinate_reference_system!: string;
    access?: DatasetAccess;
    bbox!: BoundingBox;

    constructor(data?: IDataset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bbox = new BoundingBox();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.kommune = data["kommune"];
            this.fylke = data["fylke"];
            this.sone = data["sone"];
            this.description = data["description"];
            this.resolution = data["resolution"];
            this.coordinate_reference_system = data["coordinate_reference_system"];
            this.access = data["access"];
            this.bbox = data["bbox"] ? BoundingBox.fromJS(data["bbox"]) : new BoundingBox();
        }
    }

    static fromJS(data: any): Dataset {
        data = typeof data === 'object' ? data : {};
        let result = new Dataset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["kommune"] = this.kommune;
        data["fylke"] = this.fylke;
        data["sone"] = this.sone;
        data["description"] = this.description;
        data["resolution"] = this.resolution;
        data["coordinate_reference_system"] = this.coordinate_reference_system;
        data["access"] = this.access;
        data["bbox"] = this.bbox ? this.bbox.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDataset {
    id: string;
    name: string;
    kommune?: number;
    fylke?: number;
    sone?: number;
    description?: string;
    resolution?: number;
    coordinate_reference_system: string;
    access?: DatasetAccess;
    bbox: BoundingBox;
}

export class Locks implements ILocks {
    id?: number;
    username?: string;
    features?: Features[];

    constructor(data?: ILocks) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.username = data["username"];
            if (Array.isArray(data["features"])) {
                this.features = [] as any;
                for (let item of data["features"])
                    this.features!.push(Features.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Locks {
        data = typeof data === 'object' ? data : {};
        let result = new Locks();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILocks {
    id?: number;
    username?: string;
    features?: Features[];
}

export class BoundingBox implements IBoundingBox {
    ll?: number[];
    ur?: number[];

    constructor(data?: IBoundingBox) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["ll"])) {
                this.ll = [] as any;
                for (let item of data["ll"])
                    this.ll!.push(item);
            }
            if (Array.isArray(data["ur"])) {
                this.ur = [] as any;
                for (let item of data["ur"])
                    this.ur!.push(item);
            }
        }
    }

    static fromJS(data: any): BoundingBox {
        data = typeof data === 'object' ? data : {};
        let result = new BoundingBox();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ll)) {
            data["ll"] = [];
            for (let item of this.ll)
                data["ll"].push(item);
        }
        if (Array.isArray(this.ur)) {
            data["ur"] = [];
            for (let item of this.ur)
                data["ur"].push(item);
        }
        return data; 
    }
}

export interface IBoundingBox {
    ll?: number[];
    ur?: number[];
}

export class ErrorDto implements IErrorDto {
    type!: string;
    title!: string;
    status?: number;
    detail?: string;
    instance?: string;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.title = data["title"];
            this.status = data["status"];
            this.detail = data["detail"];
            this.instance = data["instance"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data; 
    }
}

export interface IErrorDto {
    type: string;
    title: string;
    status?: number;
    detail?: string;
    instance?: string;
}

export class Lock implements ILock {
    type!: LockType;
    id?: number;

    constructor(data?: ILock) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Lock {
        data = typeof data === 'object' ? data : {};
        let result = new Lock();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILock {
    type: LockType;
    id?: number;
}

export class Lock2 implements ILock2 {
    type!: Lock2Type;
    id?: number;

    constructor(data?: ILock2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Lock2 {
        data = typeof data === 'object' ? data : {};
        let result = new Lock2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILock2 {
    type: Lock2Type;
    id?: number;
}

export class Anonymous implements IAnonymous {
    dataset?: string;
    locks?: Locks;

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dataset = data["dataset"];
            this.locks = data["locks"] ? Locks.fromJS(data["locks"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataset"] = this.dataset;
        data["locks"] = this.locks ? this.locks.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAnonymous {
    dataset?: string;
    locks?: Locks;
}

export enum DatasetAccess {
    Read_only = "read_only", 
    Read_write = "read_write", 
}

export class Features implements IFeatures {
    lokalid?: string;

    constructor(data?: IFeatures) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lokalid = data["lokalid"];
        }
    }

    static fromJS(data: any): Features {
        data = typeof data === 'object' ? data : {};
        let result = new Features();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lokalid"] = this.lokalid;
        return data; 
    }
}

export interface IFeatures {
    lokalid?: string;
}

export enum LockType {
    User_lock = "user_lock", 
    Lock_id = "lock_id", 
    Optimistic_locking = "optimistic_locking", 
}

export enum Lock2Type {
    User_lock = "user_lock", 
    Lock_id = "lock_id", 
    Optimistic_locking = "optimistic_locking", 
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

}